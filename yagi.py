# Filename : yagi.py
# Author: Janne Toivola, OH2GXN
# $Id$

import sys
import numpy
import argparse


class Yagi:
    '''An object representing a Yagi-Uda antenna and interfacing NEC2 command
    line program'''

    def __init__(self, dimensions, diam=0.01, cond=2.4938e7):
        '''Constructs an E-element Yagi antenna based on the given dimensions
	   (where E > 1). The parameter is E-by-2, E-by-3, or E-by-4 matrix:
           [pos0,len0,diam0,cond0; pos1,len1,diam1,cond1...], where
	   - pos  :: yagi element position (in meters) on the boom,
           - len  :: element length (in m, symmetric),
	   - diam :: optional element diameter (in m, default 10mm), and
           - cond :: optional element conductivity (in S, default Alum.).
	   The first element is typically the reflector, the second one is
           the driven element. If the matrix contains only 2 columns, the
           given default element diameter is used for all elements.'''

        # NOTE: Conductivity of Al is 2.4938e7 Siemens
        
	# check matrix size, NOTE: does not allow a plain dipole (vector)
        shape = dimensions.shape
        if (len(shape) != 2):
            raise RuntimeError("Invalid matrix of antenna dimensions: %s" %
                               repr(dimensions))

        # Copy values
        matrix = numpy.zeros((shape[0],4), numpy.float)
        if (shape[1] < 4):
            matrix[:,3] = cond # default conductivity
            if (shape[1] < 3):
                matrix[:,2] = diam # default diameter
            else:
                matrix[:,2] = dimensions[:,2]
        else:
            matrix[:,2:4] = dimensions[:,2:4]
        matrix[:,1] = dimensions[:,1] # lengths
            
        # eliminate offset (reflector position == 0)
        Xmin = numpy.min(dimensions[:,0])
        matrix[:,0] = dimensions[:,0] - Xmin
        
        self.dimensions = matrix


    def setBoom(self, length, diameter, cond=2.4938e7):
        '''Adds the specified boom to the design.'''
	self.boom = numpy.array([length,diameter,cond], numpy.float)


    def setPole(self, height, diameter, cond=2.4938e7):
        '''Adds a supporting vertical pole.'''
       	self.pole = numpy.array([height,diameter,cond], numpy.float)


    def toVector(self):
        '''Represents the free parameters (element len,pos) as a vector.'''
        return self.dimensions[:,0:2].flatten() # TODO: correct?

    def fromVector(self, newDimensions):
        '''Set the free parameters according to updated values.'''
        E = self.dimensions.shape[0]
        self.dimensions[:,0:2] = newDimensions.reshape((E,2)) # TODO: correct?
        

    def readNEC(self, stream):
        '''Reads other simulation details, like EX & FR, from file'''
        # TODO


    def fprintNEC(self, stream):
        '''Prints a NEC2 compatible description of the antenna.'''
        
        # Comment lines and Comment End
        W = self.dimensions # shorter name for wires
        E = W.shape[0]
        stream.write("CM %d-el yagi: NEC file generated by PyPSO\n" % E)
        stream.write("CE\n")
        
        # Geometry
        S = 11 # number of wire segments in simulation
        Z = 0  # default height
        if self.pole is not None:
            Z = self.pole[0] # + element spacing?
        if self.boom is not None:
            # approx. CoG with boom diameter >> element diameter
            CoG = 0.5*self.boom[0] 
        else:
            # approx. CoG with uniform element material
            CoG = numpy.dot(W[:,0],W[:,1])/numpy.sum(W[:,1])
            # TODO: better approximations?
        
        # Elements: tags [1:E]
        for e in range(0,E):
            # Wire Tag Segs X1 Y1 Z1 X2 Y2 Z2 Radius
            stream.write("GW %d %d %g %g %g %g %g %g %g\n" %
                         ((e+1), S,
                          W[e,0]-CoG, -0.5*W[e,1], Z,
                          W[e,0]-CoG,  0.5*W[e,1], Z,
                          W[e,2] * 0.5))
        # Boom at Y = 0.0, tag = E+1
        if self.boom is not None:
            stream.write("GW %d %d %g 0.0 %g %g 0.0 %g %g\n" %
                         (E+1), S,
                         -CoG, Z,
                         self.boom[0]-CoG, Z,
                         self.boom[1] * 0.5)
        # Mast at (X,Y) = (0.0,0.0)
        if self.pole is not None:
            stream.write("GW %d %d 0.0 0.0 0.0 0.0 0.0 %g %g\n" %
                         (E+2), S, Z, self.pole[1])
        stream.write("GE 1\n") # Geometry End

        # Ground
        dielectric   = 13    # TODO: some reasonable value?
        conductivity = 0.005 # Siemens
        stream.write("GN 2 0 0 0 %g %g 0 0 0 0\n", dielectric, conductivity)

        # Excitation with voltage source (driven element = tag 2)
        V = (10.0, 0.0) # Volts, no phase considerations
        stream.write("EX 0 %d %d 0 %g %g\n" % (2, (S//2)+1, V[0], V[1]))

        # Wire losses
        for e in range(0,E):
            # Loading Type Tag StartSeg EndSeg Conductivity
            stream.write("LD 5 %d 1 %d %g\n" % ((e+1), S, W[e,3]))
        # NOTE: possibility for trap coils etc. with Type 4 (R,L,C not Cond)
        
        # TODO: Transmission Line: TL Tag1 Seg1 Tag2 Seg2 Z0 Len/VF 0 0 0 0
        # where the mechanical cable Length is divided with the Velocity Factor
        # e.g. (abs(W[2,0]-CoG) + Z) / 0.66, but needs to be excited from
        # an additional wire element Tag1 at the bottom of the mast...
        # and the match+balun for the driven element???
        
        # TODO: FR, RP according to criteria?

        stream.write("EN\n") # The End


    def evaluate(self, criterion):
        '''Runs NEC2 and evaluates the given design criterion.'''
        # TODO: coupled with the NEC RP card?
        return 0.0



def addParameters(parser):
    '''Command line parameters for stand-alone NEC runs.'''
    parser.add_argument('file', metavar='file.csv',
        help='file with element length,position,[diameter,[conductivity]]')
    # TODO: others


if __name__ == '__main__':
    # parse command line arguments
    note='Run NEC2 for a given Yagi antenna.'
    parser = argparse.ArgumentParser(description=note)
    addParameters(parser)
    args = parser.parse_args()

    # build the antenna
    antenna = yagi( numpy.loadtxt( args.file ))
    # TODO: other parameters

    # print the NEC stuff
    antenna.fprintNEC(sys.stdout)

    # run NEC
    sys.stderr.write("SWR: %f\n" % antenna.evaluate("SWR"))
    
