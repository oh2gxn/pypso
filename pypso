#!/usr/bin/python
# Filename : pypso
# Author : Janne Toivola, OH2GXN
# $Id$

# nuts and bolts
import sys
import argparse
import numpy

# GUI and plots
import Tkinter
import tkFileDialog
import tkSimpleDialog
import pylab
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.backends.backend_tkagg import NavigationToolbar2TkAgg

# Yagi-specific stuff
from yagi import *

title = 'PyPSO 0.1'


# NOTE: class, named tuple, or dictionary?
class PSOsettings:
    """Parameters related to running Particle Swarm Optimization."""
    def __init__(self, particles=10, width=1.0, greed=0.5, trust=0.5):
        self.N = particles # number of particles
        self.W = width     # relative width of initial cloud of particles
        self.G = greed     # factor for (1 - inertia)
        self.T = trust     # update factor between personal and global best
        self.criterion = 'weight' # Python expression evaluated by particles
        # TODO: validation of parameter values!

            
class PSOdialog(tkSimpleDialog.Dialog):
    """Simple dialog window for editing PSO parameter values"""

    def __init__(self, parent, settings, title=None):
        self.result = settings # NOTE: has to happen before self.body()
        tkSimpleDialog.Dialog.__init__(self, parent, title)
        
    def body(self, master):
        Tkinter.Label(master, text="Number of particles:").grid(row=0)
        Tkinter.Label(master, text="Initial swarm width:").grid(row=1)
        Tkinter.Label(master, text="Particle inertia:").grid(row=2)
        Tkinter.Label(master, text="Personal vs. Global best:").grid(row=3)
        Tkinter.Label(master, text="Optimization criterion:").grid(row=4)

        self.e1 = e = Tkinter.Entry(master)
        e.delete(0, Tkinter.END)
        e.insert(0, "%d" % self.result.N)
        self.e2 = e = Tkinter.Entry(master)
        e.delete(0, Tkinter.END)
        e.insert(0, "%d" % self.result.W)
        self.e3 = e = Tkinter.Entry(master)
        e.delete(0, Tkinter.END)
        e.insert(0, "%d" % self.result.G)
        self.e4 = e = Tkinter.Entry(master)
        e.delete(0, Tkinter.END)
        e.insert(0, "%d" % self.result.T)
        self.e5 = e = Tkinter.Entry(master)
        e.delete(0, Tkinter.END)
        e.insert(0, self.result.getCriterion())
        # TODO: initial content of text fields from self.result?

        self.e1.grid(row=0, column=1)
        self.e2.grid(row=1, column=1)
        self.e3.grid(row=2, column=1)
        self.e4.grid(row=3, column=1)
        self.e5.grid(row=4, column=1)
        return self.e1 # initial focus
        
    def apply(self):
        N = int(self.e1.get())
        W = float(self.e2.get())
        G = float(self.e3.get())
        T = float(self.e4.get())
        f = self.e5.get()
        pso = PSOsettings(N,W,G,T)
        pso.criterion = f # NOTE: no way of validating at this point?
        self.result = pso
    

class MainWindow:
    """The main window."""

    def __init__(self, master):
        # current state
        self.__reset()
        self.pso = PSOsettings() # starts with the same default values

        # GUI stuff
        self.root = master
        self.__setMenus(master)
        self.__setWindow(master)

        
    def __reset(self):
        self.currentBest = 0 # index of the particle with global best
        self.swarm  = None   # list of all particles, or None
        self.swarmX = None   # current state of each particle
        self.swarmP = None   # personal best state of each particle
        self.swarmV = None   # current velocity of each particle
        self.data   = None   # evaluations of the particles for each iteration
        #self.pso settings stay the same
        
        
    def __setMenus(self, master):
        # menu bar
        self.menu = Tkinter.Menu(master)
        master.config(menu=self.menu)

        # File submenu
        self.loadOptions = opts = {}
        opts['defaultextension'] = '.csv' # or .nec ?
        opts['filetypes'] = [('all files', '.*'),('dimension tables', '.csv')]
        opts['parent'] = master
        opts['title'] = 'Load initial guess'

        self.saveOptions = opts = {}
        opts['defaultextension'] = '.csv' # or .nec ?
        opts['filetypes'] = [('all files', '.*'),('dimension tables', '.csv')]
        opts['parent'] = master
        opts['title'] = 'Save current best'

        self.exportOptions = opts = {}
        opts['defaultextension'] = '.nec'
        opts['filetypes'] = [('all files', '.*'),('NEC files', '.nec')]
        opts['parent'] = master
        opts['title'] = 'Export current best'

        self.fileMenu = Tkinter.Menu(self.menu)
        self.menu.add_cascade(label="File", menu=self.fileMenu)
        self.fileMenu.add_command(label="New...", 
                                  command=self.new)
        self.fileMenu.add_command(label="Load initial...", 
                                  command=self.load)
        self.fileMenu.add_command(label="Save...",
                                  command=self.save)
        self.fileMenu.add_command(label="Export NEC...",
                                  command=self.export)
        self.fileMenu.add_command(label="Quit!", 
                                  command=self.quit)

        # Settings submenu
        self.setMenu = Tkinter.Menu(self.menu)
        self.menu.add_cascade(label="Settings", menu=self.setMenu)
        self.setMenu.add_command(label="PSO parameters...", 
                                 command=self.updateSettings)
        self.setMenu.add_command(label="About", 
                                 command=self.about)
        # TODO: configuration window for PSOsettings


    def __setWindow(self, master):
        # a frame for all the stuff
        self.frame = frame = Tkinter.Frame(master)
        frame.bind("<Return>", self.next) # Press enter to progress

        # a canvas for plotting evaluation history
        self.figure = fig = pylab.figure(1)
        self.ax = ax = fig.add_subplot(111)
        ax.grid(True)
        ax.set_title("Progress of the optimization")
        ax.set_xlabel("Iteration")
        ax.set_ylabel("Evaluation")
        ax.axis([0,10,0,10]) # TODO: better ideas?
        self.lines = None # ax.plot(self.data, '-')
        
        self.canvas = canvas = FigureCanvasTkAgg(fig, frame)
        canvas.show()
        canvas.get_tk_widget().pack(side=Tkinter.TOP,
                                    fill=Tkinter.BOTH, 
                                    expand=1)
        #canvas.get_tk_widget().grid(row=1, column=0)
        
        self.toolbar = NavigationToolbar2TkAgg(canvas, frame)
        self.toolbar.update()
        canvas._tkcanvas.pack(side=Tkinter.TOP, fill=Tkinter.BOTH, expand=1)
        #canvas._tkcanvas.grid(row=0, column=0)

        frame.pack()
        
        # a button for randomizing the current guess
        self.rButton = Tkinter.Button(self.frame,\
                                      name='rbutton',\
                                      text='Randomize',\
                                      command=self.randomize,
                                      state=Tkinter.DISABLED)
        self.rButton.pack(side=Tkinter.LEFT)
        #self.rButton.grid(row=2, column=0)

        # a button for advancing the optimization for one interation
        self.nButton = Tkinter.Button(self.frame,\
                                      name='nbutton',\
                                      text='Next step',\
                                      command=self.next,
                                      state=Tkinter.DISABLED)
        self.nButton.pack(side=Tkinter.RIGHT)
        #self.nButton.grid(row=2, column=1)

        # status bar
        self.statusBar = Tkinter.Label(master, text="", bd=1, 
                                       relief=Tkinter.SUNKEN, 
                                       anchor=Tkinter.W)
        self.statusBar.pack(side=Tkinter.BOTTOM, fill=Tkinter.X)
        #self.statusBar.grid(row=3, column=0)

        frame.pack()



    def new(self):
        """TODO: a dialog for a starting with a new guess..?"""
        sys.stderr.write("Error: fancy GUI not implemented yet. Use load.\n")
        self.rButton.config(state=Tkinter.DISABLED)
        self.nButton.config(state=Tkinter.DISABLED)
        self.__reset()
        # TODO: clear the plot too!
        # TODO: ask for number of elements and frequency band?


    def load(self, filename=None):
        """Dialog for loading the initial guess from a file."""
        if filename is None:
            filename = tkFileDialog.askopenfilename(**self.loadOptions)
        guess = Yagi.loadCSV( filename )
        self.swarm = [guess]
        self.currentBest = 0
        self.report("Current guess loaded from %s." % filename)
        self.rButton.config(state=Tkinter.NORMAL)
        

    def save(self):
        """Dialog for saving the current best dimension vector to a CSV file."""
        filename = tkFileDialog.asksaveasfilename(**self.saveOptions)
        self.swarm[self.currentBest].saveCSV( filename )
        self.report("Current best saved to %s." % filename)


    def export(self):
        filename = tkFileDialog.asksaveasfilename(**self.exportOptions)
        fid = open(filename, 'w')
        self.swarm[self.currentBest].fprintNEC(fid)
        fid.close()
        self.report("Current best saved to %s." % filename)


    def about(self):
        """Shows some basic info."""
        sys.stderr.write("%s\n" % title) # TODO: GUI window?


    def updateSettings(self):
        dialog = PSOdialog(self.root, self.pso, "PSO parameters")
        self.pso = dialog.result
        

    def quit(self):
        """Does some clean-up and quits the program."""
        # TODO: save something to a file?
        sys.stderr.write('Bye.\n')
        self.root.quit()
        self.root.destroy()


    def report(self, message):
        """Sets the status bar."""
        self.statusBar.configure(text=message)
        self.statusBar.update_idletasks()


    def randomize(self, N=10, sigma=1.0):
        """Takes the best design and produces a swarm of N
        perturbed versions of it."""
        if self.swarm is None:
            self.load()
        vector = self.swarm[self.currentBest].toVector()
        M = vector.shape[0]
        self.swarmX = X  = numpy.zeros((N, M), numpy.float)
        self.swarmP = P  = numpy.zeros((N, M), numpy.float)
        self.swarmV = V  = numpy.zeros((N, M), numpy.float)
        self.data = data = numpy.zeros((N, 1), numpy.float)
        X[0,:] = vector
        P[0,:] = vector
        V[0,:] = numpy.zeros_like(vector)
        self.report("Evaluating initial guess...")
        data[0,0] = self.swarm[self.currentBest].evaluate(self.pso.criterion)
        for n in range(1,N):
            anotherX = numpy.ones_like(vector)
            anotherV = numpy.ones_like(vector)
            for m in range (0,M):
                anotherX[m] = (0.5 + sigma*numpy.random.rand()) * vector[m]
                anotherV[m] = 0.1 * (sigma*numpy.random.rand()-0.5) * vector[m]
            another = self.swarm[self.currentBest].fromVector(anotherX)
            self.swarm.append(another)
            X[n,:] = anotherX
            P[n,:] = anotherX
            V[n,:] = anotherV
            self.report("Evaluating particle %d / %d..." % (n+1,N))
            data[n,0] = another.evaluate(self.pso.criterion)
        self.report("Random swarm of particles ready.")
        self.nButton.config(state=Tkinter.NORMAL)
        self.lines = self.ax.plot(numpy.zeros((N,1)), self.data[:,0], 'o')
        self.ax.autoscale()


    def next(self):
        """Evaluates the current swarm of designs and performs one step of
        Particle Swarm Optimization."""
        # TODO: parallel execution?
        if self.swarmX is None:
            sys.stderr.write("You must load and randomize first.\n")
            return
        N = self.swarmX.shape[0]

        # check which particle is the current best
        bestValue = numpy.min(self.data[self.currentBest,:]) # TODO: store?
        for n in range(0,N):
            personalBest = numpy.min(self.data[n,:]) # FIXME: check only latest?
            if personalBest < bestValue:
                bestValue = personalBest
                self.currentBest = n
        self.report("Particle %d seems best so far: %g" % 
                    (self.currentBest, bestValue))
        # TODO: accelerate swarmV towards currentBest (gravitation)
        # TODO: update swarmX by swarmV
        # TODO: update swarm from swarmX
        # TODO: evaluate each new particle and append to self.data
        # TODO: update the plot
        

if __name__ == '__main__':
    # Command line arguments
    note = 'A program for running Particle Swarm Optimization for yagis'
    parser = argparse.ArgumentParser(description=note)
    parser.add_argument('file', nargs='?', metavar='elements.csv',
        help='file with element length,position,[diameter,[conductivity]]')
    parser.add_argument('-b', '--boom', metavar='length,diameter',
        help='optional boom length and diameter')
    parser.add_argument('-p', '--pole', metavar='height,diameter',
        help='optional antenna mast height and diameter')
    args = parser.parse_args()
        
    # the root widget
    root = Tkinter.Tk()
    root.title(title)
    
    # instance of our application
    win = MainWindow(root)
    if args.file is not None:
        win.load(filename=args.file)
    # FIXME: so how to set boom & pole etc.?
    
    # start the Tkinter event loop
    root.mainloop()

else:
    sys.stderr.write('NOTE: %s was not meant to be imported.\n' % __name__)
